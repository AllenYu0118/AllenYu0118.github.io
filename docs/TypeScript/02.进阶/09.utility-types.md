---
title: 工具类型
date: 2022-04-01 21:53:40
permalink: /pages/23d841/
categories:
  - TypeScript
tags:
  -
---

## 工具类型 (Utility Types)

`TypeScript` 提供了一些工具类型，方便进行类型上的转换。这些工具类型是全局可见的。

## Partial

构造一个新类型，使类型 `T`上的所有属性都变成可选的。

### 使用

```typescript
interface Person {
  name: string
  age: number
}

type PersonOptional = Partial<Person>

// 相当于
type PersonOptional = {
  name?: string
  age?: number
}
```

### 实现

```typescript
type Partial<T> = {
  [K in keyof T]?: T[K]
}
```

---

## Required

设置类型的所有属性为必须项。和 `Partial` 是相反的。

### 使用

```typescript
interface Person {
  name?: string
  age?: number
}

const Jack: Person = { name: 'Jack' }
const Lucy: Required<Person> = { name: 'Lucy' }

// Property 'age' is missing in type '{ name: string; }' but required in type 'Required<Person>'.(2741)
```

### 实现

```typescript
type Required<T> = {
  [K in keyof T]-?: T[K]
}
```

注意 `-?` 表示**非可选**，这里如果不加 `-?` 在遇到 `T` 的属性为可选时，就无法变成必选属性，这个就是指同态拷贝。

举个例子 🌰

```typescript
interface T {
  name: string
  age?: number
}

// 实现一个不使用 `-?` 的 Required
type Required<T> = {
  [K in keyof T]: T[K]
}

// Foo = { name: string, age?: number | undefined }
type Foo = Required<T>

// 添加 `-?`
type Required<T> = {
  [K in keyof T]-?: T[K]
}

// Foo = { name: string, age: number }
type Foo = Required<T>
```

---

## Readonly

设置类型的所有属性为 `readonly`。也就是不能再被赋值。

### 使用

```typescript
interface Person {
  name: string
  age: number
}
const Lucy: Readonly<Person> = { name: 'Lucy', age: 18 }
Lucy.name = 'Jack'
// Cannot assign to 'name' because it is a read-only property.
```

### 实现

```typescript
type Readonly<T> = {
  readonly [K in keyof T]: T[K]
}
```

## Record\<K, T>

构造一个对象类型, 它的 `Keys` 是 `K`，它的 `value` 是 `T`。

### 使用

```typescript
type Point = {
  lat: number
  lng: number
}
type Line = Record<'start' | 'end', Point>

// 相当于
type Line = {
  start: { lat: number; lng: number }
  end: { lat: number; lng: number }
}
```

### 实现

```typescript
type Record<K extends keyof any, T> = {
  [P in K]: T
}
```

## Pick\<T, K>

接口类型工具，从 `T` 类型中，选取 `K` 选项的属性，并组成新的类型。

### 使用

```typescript
type House = {
  lat: number
  lng: number
  address: string
  color: string
}

type Point = Pick<House, 'lat' | 'lng'>

// 相当于
type Point = {
  lat: number
  lng: number
}
```

### 实现

```typescript
type Pick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

---

## Exclude\<T, U>

联合类型工具，排除联合类型 `T` 中与 `U` 相等的类型，返回一个联合类型。

### 使用

```typescript
interface Person {
  name: string
  age: number
}

type P = Exclude(keyof Person, 'age')
```

### 实现

```typescript
type MyExclude<T, U> = T extends U ? never : T
```

## Omit\<T, K>

从类型 `T` 中移除 `K` 中所有的属性。

### 使用

```typescript
type House = {
  lat: number
  lng: number
  address: string
  color: string
}

// 移除 House 类型中的 color 和 address
type Point = Pick<House, 'color' | 'address'>

// 相当于
type Point = {
  lat: number
  lng: number
}
```

### 实现

```typescript
type MyExclude<T, U> = T extends U ? never : T
type MyOmit<T, K extends keyof T> = {
  [P in MyExclude<T, U>]: T[P]
}
```

## Extract\<T, U>

联合类型工具，联合类型 `T` 和 `U` 的交集。

### 使用

```typescript
type T = Extract<'name' | 'age' | 'sex', 'age' | 'height'>

// 相当于
type T = 'age'
```

### 实现

```typescript
type MyExtract<T, U> = T extend U ? T : never
```

---

## NonNullable

排除联合类型中为 `null` 和 `undefined` 的类型

### 使用

```typescript
type T = NonNullable<string | number | undefined | null>

// 等于
type T = string | number
```

### 实现

```typescript
type MyNonNullable<T> = Exclude<T, null | undefined>
```

## Parameters

获取函数的参数类型，将每个参数类型放在一个元组中

### 使用

```typescript
declare function f1(arg: { a: number; b: string })

type T0 = Parameters<() => string>
// T0 = []

type T1 = Parameters<(s: string) => void>
// T1 = [s: string]

type T2 = Parameters<<T>(arg: T) => T>
// T2 = [arg: unknown]

type T3 = Parameters<typeof f1>
// T3 = [arg: { a: number, b: string }]
```

### 实现

```typescript
type MyParameters<T extends (...arg: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never
```

## 参考

- [TypeScript 入门教程 - 声明合并](https://ts.xcatliu.com/advanced/declaration-merging.html)
