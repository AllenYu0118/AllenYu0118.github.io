<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类型断言 (Type Assertion) | Allen Yu</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/icon.png">
    <meta name="description" content="前端工程师，技术爱好者，记录自己的学习内容以及技术思考">
    <link rel="preload" href="/assets/css/0.styles.8f621e2c.css" as="style"><link rel="preload" href="/assets/js/app.ac774736.js" as="script"><link rel="preload" href="/assets/js/2.ecc89b73.js" as="script"><link rel="preload" href="/assets/js/28.e277d069.js" as="script"><link rel="prefetch" href="/assets/js/10.e9a7a38d.js"><link rel="prefetch" href="/assets/js/11.fe9a161d.js"><link rel="prefetch" href="/assets/js/12.6757c861.js"><link rel="prefetch" href="/assets/js/13.0dc34619.js"><link rel="prefetch" href="/assets/js/14.941c5204.js"><link rel="prefetch" href="/assets/js/15.9650f920.js"><link rel="prefetch" href="/assets/js/16.eabf4b3a.js"><link rel="prefetch" href="/assets/js/17.274013f2.js"><link rel="prefetch" href="/assets/js/18.29deb47b.js"><link rel="prefetch" href="/assets/js/19.c63d1482.js"><link rel="prefetch" href="/assets/js/20.89e846fb.js"><link rel="prefetch" href="/assets/js/21.5946b227.js"><link rel="prefetch" href="/assets/js/22.191df837.js"><link rel="prefetch" href="/assets/js/23.7416e54a.js"><link rel="prefetch" href="/assets/js/24.f013c36c.js"><link rel="prefetch" href="/assets/js/25.5300265d.js"><link rel="prefetch" href="/assets/js/26.3bda9cee.js"><link rel="prefetch" href="/assets/js/27.9d8e0e0b.js"><link rel="prefetch" href="/assets/js/29.32c0c7a9.js"><link rel="prefetch" href="/assets/js/3.512cc10a.js"><link rel="prefetch" href="/assets/js/30.53e76366.js"><link rel="prefetch" href="/assets/js/31.1197b67c.js"><link rel="prefetch" href="/assets/js/32.8a5b4edc.js"><link rel="prefetch" href="/assets/js/33.288d6022.js"><link rel="prefetch" href="/assets/js/34.ea2481ea.js"><link rel="prefetch" href="/assets/js/35.dfe2b968.js"><link rel="prefetch" href="/assets/js/36.551ca165.js"><link rel="prefetch" href="/assets/js/4.82bfc8e0.js"><link rel="prefetch" href="/assets/js/5.88ace8cf.js"><link rel="prefetch" href="/assets/js/6.db1d197d.js"><link rel="prefetch" href="/assets/js/7.37860287.js"><link rel="prefetch" href="/assets/js/8.9ea21b86.js"><link rel="prefetch" href="/assets/js/9.236c9fad.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f621e2c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/icon.png" alt="Allen Yu" class="logo"> <span class="site-name can-hide">Allen Yu</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/intersection-observer.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/vue3/" class="nav-link">
  Vue 3.0
</a></li><li class="dropdown-item"><!----> <a href="/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/other/browser-cache.html" class="nav-link">
  Other
</a></li></ul></div></div><div class="nav-item"><a href="/ts/" class="nav-link router-link-active">
  TypeScript
</a></div> <a href="https://github.com/yuxiaolei1989/yuxiaolei1989.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/intersection-observer.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/vue3/" class="nav-link">
  Vue 3.0
</a></li><li class="dropdown-item"><!----> <a href="/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/other/browser-cache.html" class="nav-link">
  Other
</a></li></ul></div></div><div class="nav-item"><a href="/ts/" class="nav-link router-link-active">
  TypeScript
</a></div> <a href="https://github.com/yuxiaolei1989/yuxiaolei1989.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/ts/" class="sidebar-link">简介</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ts/primitive-data-types.html" class="sidebar-link">原始数据类型</a></li><li><a href="/ts/any.html" class="sidebar-link">任意值</a></li><li><a href="/ts/type-inference.html" class="sidebar-link">类型推论</a></li><li><a href="/ts/union-types.html" class="sidebar-link">联合类型</a></li><li><a href="/ts/interfaces.html" class="sidebar-link">接口</a></li><li><a href="/ts/type-of-array.html" class="sidebar-link">数组类型</a></li><li><a href="/ts/type-of-function.html" class="sidebar-link">函数类型</a></li><li><a href="/ts/type-assertion.html" class="active sidebar-link">类型断言</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#类型断言-type-assertion" class="sidebar-link">类型断言 (Type Assertion)</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#类型断言的用途" class="sidebar-link">类型断言的用途</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#将一个联合类型断言为其中一个类型" class="sidebar-link">将一个联合类型断言为其中一个类型</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#将一个父类断言为更加具体的子类" class="sidebar-link">将一个父类断言为更加具体的子类</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#将任何类型断言为-any" class="sidebar-link">将任何类型断言为 any</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#将-any-断言为一个具体的类型" class="sidebar-link">将 any 断言为一个具体的类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#类型断言的限制" class="sidebar-link">类型断言的限制</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#双重断言" class="sidebar-link">双重断言</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#类型断言-vs-类型转换" class="sidebar-link">类型断言 VS 类型转换</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#类型断言-vs-类型声明" class="sidebar-link">类型断言 VS 类型声明</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#类型断言-vs-泛型" class="sidebar-link">类型断言 VS 泛型</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#问答" class="sidebar-link">问答</a></li><li class="sidebar-sub-header"><a href="/ts/type-assertion.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/ts/declaration-files.html" class="sidebar-link">声明文件</a></li><li><a href="/ts/build-in-objects.html" class="sidebar-link">内置对象</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实战</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="类型断言-type-assertion"><a href="#类型断言-type-assertion" class="header-anchor">#</a> 类型断言 (Type Assertion)</h2> <p>类型断言可以手动指定一个值的类型。</p> <h2 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h2> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 值 as 类型</span>
value <span class="token keyword">as</span> <span class="token keyword">type</span>
</code></pre></div><p>或</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// &lt;类型&gt;值</span>
<span class="token operator">&lt;</span><span class="token keyword">type</span><span class="token operator">&gt;</span>value
</code></pre></div><p>在 <code>tsx</code> 语法（<code>React</code> 的 <code>jsx</code> 语法的 <code>ts</code> 版）中必须使用前者，即 <code>值 as 类型</code> 。</p> <p>形如 <code>&lt;Foo&gt;</code> 的语法在 <code>tsx</code> 中表示的是一个 <code>ReacNode</code>，在 <code>ts</code> 中除了表示类型断言外，也可能是表示一个泛型。</p> <p>故建议大家在使用类型断言时，统一使用 <code>值 as 类型</code> 这样的语法！</p> <h2 id="类型断言的用途"><a href="#类型断言的用途" class="header-anchor">#</a> 类型断言的用途</h2> <p>类型断言的常见用途有以下几种：</p> <h3 id="将一个联合类型断言为其中一个类型"><a href="#将一个联合类型断言为其中一个类型" class="header-anchor">#</a> 将一个联合类型断言为其中一个类型</h3> <p>当 <code>TypeScript</code> 不确定一个联合类型的变量到底是哪个类型时，只能访问联合类型所有类型中的共有的属性和方法。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token parameter">animal<span class="token operator">:</span> Cat <span class="token operator">|</span> Fish</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> animal<span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
</code></pre></div><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性和方法，比如：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token parameter">animal<span class="token operator">:</span> Cat <span class="token operator">|</span> Fish</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> animal<span class="token punctuation">.</span>swim <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token comment">// 类型“Cat | Fish”上不存在属性“swim”。</span>
<span class="token comment">// 类型“Cat”上不存在属性“swim”。ts(2339)</span>
</code></pre></div><p>上面的例子中，获取 <code>animal.swim</code> 就会报错，因为 <code>swim</code> 不是联合类型 <code>Cat | Fish</code> 公共属性或者方法。</p> <p>此时，可以使用类型断言，将 <code>animal</code> 断言为 <code>Fish</code>：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token parameter">animal<span class="token operator">:</span> Cat <span class="token operator">|</span> Fish</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>animal <span class="token keyword">as</span> Fish<span class="token punctuation">)</span><span class="token punctuation">.</span>swim <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样就可以解决访问 <code>animal.swim</code> 报错的问题了。</p> <p>需要注意的是，类型断言只能欺骗 <code>TypeScript</code> 编译器，无法避免运行时的错误，滥用类型断言可能会导致运行时错误：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token parameter">animal<span class="token operator">:</span> Cat <span class="token operator">|</span> Fish</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">;</span><span class="token punctuation">(</span>animal <span class="token keyword">as</span> Fish<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'mimi'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">run</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mimi'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// animal.swim is not a function</span>
</code></pre></div><p>上面的例子编译时不会报错，但在运行时会报错：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Uncaught TypeError<span class="token operator">:</span> animal<span class="token punctuation">.</span>swim is not a <span class="token keyword">function</span>
</code></pre></div><p>原因是 <code>(animal as Fish).swim()</code> 这段代码隐藏了 <code>animal</code> 可能是 <code>Cat</code> 的情况，将 <code>animal</code> 直接断言为 <code>Fish</code> 类型了，而 <code>TypeScript</code> 信任了我们的断言，故在调用 <code>swim()</code> 没有编译错误。</p> <p>可是 <code>getName</code> 函数接受的是 <code>Cat | Fish</code>，一旦传入的参数是 <code>Cat</code> 类型变量，由于 <code>Cat</code> 上没有 <code>swim</code> 方法，就会导致运行时错误。</p> <p>总之，使用类型断言时要格外小心，尽量避免断言后调用方法或者引用深层属性，减少不必要的运行时错误。</p> <h3 id="将一个父类断言为更加具体的子类"><a href="#将一个父类断言为更加具体的子类" class="header-anchor">#</a> 将一个父类断言为更加具体的子类</h3> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// 原文中的示例，因为 Error 原因，运行时抛出错误</span>
<span class="token keyword">class</span> <span class="token class-name">ApiObject</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
    code<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">HttpObject</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
    statusCode<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">200</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isApiObject</span><span class="token punctuation">(</span><span class="token parameter">object<span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>object <span class="token keyword">as</span> ApiObject<span class="token punctuation">)</span><span class="token punctuation">.</span>code <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的例子中，我们声明了函数 <code>isApiError</code>，用来判断传入的参数是不是 <code>ApiError</code> 类型，那函数的参数类型需要是父类 <code>Error</code>，这样函数就能接收 <code>Error</code> 或者它的子类作为参数了。</p> <p>但是父类 <code>Error</code> 中没有 <code>code</code> 属性，故直接获取 <code>error.code</code> 会报错，需要使用类型断言获取 <code>(error as ApiError).code</code>。</p> <p>使用 <code>intanceof</code> 进行判断</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">ApiObject</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
    code<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">HttpObject</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
    statusCode<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">200</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isApiObject</span><span class="token punctuation">(</span><span class="token parameter">object<span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">ApiObject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>ApiObject</code> 是一个 <code>JavaScript</code> 的类，能够通过 <code>instanceof</code> 来判断 <code>object</code> 是否是它的实例。</p> <p>但是有些情况下，<code>ApiObject</code> 和 <code>HttpObject</code> 并不是一个类，而只是 <code>TypeScript</code> 的接口，接口只是一个类型，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 进行运行时判断了。</p> <p>这时候只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiObject</code> 类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">ApiObject</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
    code<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">HttpObject</span> <span class="token keyword">extends</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
    statusCode<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isApiObject</span><span class="token punctuation">(</span><span class="token parameter">object<span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>object <span class="token keyword">as</span> ApiObject<span class="token punctuation">)</span><span class="token punctuation">.</span>code <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token function">isApiObject</span><span class="token punctuation">(</span><span class="token punctuation">{</span> code<span class="token operator">:</span> <span class="token number">200</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token function">isApiObject</span><span class="token punctuation">(</span><span class="token punctuation">{</span> status<span class="token operator">:</span> <span class="token number">404</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><h3 id="将任何类型断言为-any"><a href="#将任何类型断言为-any" class="header-anchor">#</a> 将任何类型断言为 <code>any</code></h3> <p>理想状态下，<code>TypeScript</code> 类型系统运行良好，每个值的类型都具体而精确。</p> <p>当我们引入一个在此类型上，不存在的属性或者方法时，就会报错：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> myAge<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">18</span>
<span class="token keyword">const</span> len<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> myAge<span class="token punctuation">.</span>length

<span class="token comment">// 类型“number”上不存在属性“length”。ts(2339)</span>
</code></pre></div><p>上面的例子中，数字类型的变量 <code>myAge</code> 上是没有 <code>length</code> 属性的，故 <code>TypeScript</code> 给出了错误提示。</p> <p>这种错误提示显然是非常有用的。</p> <p>但有的时候，我们也非常确定有些代码是不会出错的，例如：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code>window<span class="token punctuation">.</span>myAge <span class="token operator">=</span> <span class="token number">18</span>

<span class="token comment">// 属性“myAge”在类型“Window &amp; typeof globalThis”上不存在。你是否指的是“Image”?ts(2551)</span>
</code></pre></div><p>上面的例子中，我们在 <code>window</code> 对象上添加了一个属性 <code>myAge</code>， 但 <code>TypeScript</code> 编译会报错，提示我们 <code>window</code> 上不存在 <code>myAge</code> 属性。</p> <p>此时，我们可以使用 <code>as any</code> 将 <code>window</code> 对象断言为 <code>any</code> 类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token punctuation">;</span><span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>myAge <span class="token operator">=</span> <span class="token number">18</span>
</code></pre></div><p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>将一个变量类型断言为 <code>any</code> ，可以说是解决 <code>TypeScript</code> 中类型问题的最后一个手段。</p></div> <p><strong>它极有可能掩盖真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p> <p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不能完全否定它的作用，我们需要在类型的严格和开发的便利性之间掌握平衡</strong>（这也是 <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals" target="_blank" rel="noopener noreferrer">TypeScript 的设计理念<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>之一），才能发挥出 <code>TypeScript</code> 最大的价值。</p> <h3 id="将-any-断言为一个具体的类型"><a href="#将-any-断言为一个具体的类型" class="header-anchor">#</a> 将 any 断言为一个具体的类型</h3> <p>遇到 <code>any</code> 时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p> <p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p> <p>举例来说，历史遗留的代码中有个 <code>getCacheData</code>，它的返回值是 <code>any</code>。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么我们在使用它时，最好能够将调用了它的返回值断言为一个精确的类型，这样就方便了后续的操作。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tom <span class="token operator">=</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Cat
tom<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的例子中，我们调用完 <code>getCacheData</code> 后，立即将它的返回值断言为 <code>Cat</code>，这样就明确了 <code>tom</code> 的类型，后续对 <code>tom</code> 的操作就有了代码补全，提高了代码的可维护性。</p> <h2 id="类型断言的限制"><a href="#类型断言的限制" class="header-anchor">#</a> 类型断言的限制</h2> <p>从上面的例子中，我们可以总结出：</p> <ul><li>联合类型可以被断言为其中一个类型</li> <li>父类可以被断言为子类</li> <li>任何类型都可以被断言为 <code>any</code></li> <li><code>any</code> 可以被断言为任何类型</li></ul> <p>那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> tom<span class="token operator">:</span> Cat <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'tom'</span><span class="token punctuation">,</span>
    <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> animal<span class="token operator">:</span> Animal <span class="token operator">=</span> tom
</code></pre></div><p>我们知道，<code>TypeScript</code> 是结构类型系统，类型之间的对比只会比较他们最终的结构，而会忽略他们定义时的关系。</p> <p>在上面的例子中，<code>Cat</code> 包含了 <code>Animal</code> 中的所有属性，除此之外，它还有一个额外的方法 <code>run</code>。</p> <p><code>TypeScript</code> 并不关心 <code>Cat</code> 和 <code>Animal</code> 之间定义时是什么关系，而只会看它们最终的结构有什么关系 -- 所以它和 <code>Cat extends Animal</code> 是等价的。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么也不难理解为什么 <code>Cat</code> 类型的 <code>tom</code> 可以赋值给 <code>Animal</code> 类型的 <code>animal</code> 了 -- 就像面向对象编程中，我们可以将子类的实例赋值给类型为父类的变量。</p> <p>我们把它换成 <code>TypeScript</code> 中更专业的说法，即：<code>Animal</code> 兼容 <code>Cat</code>。</p> <p>当 <code>Animal</code> 兼容 <code>Cat</code> 时，它们就可以相互进行类型断言了：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">testAnimal</span><span class="token punctuation">(</span><span class="token parameter">animal<span class="token operator">:</span> Animal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> animal <span class="token keyword">as</span> Cat
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">testCat</span><span class="token punctuation">(</span><span class="token parameter">cat<span class="token operator">:</span> Cat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> cat <span class="token keyword">as</span> Animal
<span class="token punctuation">}</span>
</code></pre></div><p>这样的设计其实很容易就能理解：</p> <ul><li>允许 <code>Animal as Cat</code> 是因为 「父类可以被断言为子类」。</li> <li>允许 <code>Cat as Animal</code> 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」</li></ul> <p>综上所述：</p> <ul><li>联合类型可以被断言为其中一个类型</li> <li>父类可以被断言为子类</li> <li>任何类型都可以被断言为 <code>any</code></li> <li><code>any</code> 可以被断言为任何类型</li> <li>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code>， 或者 <code>B</code> 兼容 <code>A</code></li></ul> <h2 id="双重断言"><a href="#双重断言" class="header-anchor">#</a> 双重断言</h2> <p>既然：</p> <ul><li>任何类型都可以被断言为 <code>any</code></li> <li><code>any</code> 可以被断言为任何类型</li></ul> <p>那么我们是不是可以使用双重断言 <code>as any as Foo</code> 来将任何一个类型断言为任何另一个类型呢？</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>
    <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">testCat</span><span class="token punctuation">(</span><span class="token parameter">cat<span class="token operator">:</span> Cat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>cat <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Fish
<span class="token punctuation">}</span>
</code></pre></div><p>上面的例子中，若直接使用 <code>cat as Fish</code> 肯定会报错，因为 <code>Cat</code> 和 <code>Fish</code> 相互都不兼容。</p> <p>但使用 <code>as any as Fish</code> 就不会报错了，但使用这种双重断言，十有八九是非常错误的，它很可能会导致运行时错误。</p> <p><strong>除非迫不得以，千万别用双重断言</strong></p> <h2 id="类型断言-vs-类型转换"><a href="#类型断言-vs-类型转换" class="header-anchor">#</a> 类型断言 VS 类型转换</h2> <p>类型断言只会影响 <code>TypeScript</code> 编译时的类型，类型断言语句在编译结果中会被删除：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">toBoolean</span><span class="token punctuation">(</span><span class="token parameter">something<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> something <span class="token keyword">as</span> <span class="token builtin">boolean</span>
<span class="token punctuation">}</span>

<span class="token function">toBoolean</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 返回值还是 1</span>
</code></pre></div><p>上面的例子中，将 <code>something</code> 断言为 <code>boolean</code> 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">toBoolean</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> something
<span class="token punctuation">}</span>

<span class="token function">toBoolean</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p> <p>若要进行类型转换，需要直接调用类型转换的方法：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">toBoolean</span><span class="token punctuation">(</span><span class="token parameter">something<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">Boolean</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span>

<span class="token function">toBoolean</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 返回值 true</span>
</code></pre></div><h2 id="类型断言-vs-类型声明"><a href="#类型断言-vs-类型声明" class="header-anchor">#</a> 类型断言 VS 类型声明</h2> <p>在下面的例子中：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tom <span class="token operator">=</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Cat

tom<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>我们使用 <code>as Cat</code> 将 <code>getCacheData</code> 函数返回的 <code>any</code> 类型，断言为 <code>Cat</code>。</p> <p>但实际上还有其他方案可以解决同样的问题：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tom<span class="token operator">:</span> Cat <span class="token operator">=</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">)</span>

tom<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的例子中，我们通过类型声明的方式，将 <code>tom</code> 变量声明为 <code>Cat</code> 类型，然后再将 <code>any</code> 类型的 <code>getCacheData</code> 函数返回值，赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p> <p>它们的区别，可以通过下面的例子理解：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> animal<span class="token operator">:</span> Animal <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'tom'</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> tom <span class="token operator">=</span> animal <span class="token keyword">as</span> Cat
</code></pre></div><p>在上面的例子中，由于 <code>Animal</code> 兼容 <code>Cat</code>，故可以将 <code>Animal</code> 断言为 <code>Cat</code>，并赋值给 <code>tom</code>。</p> <p>但若是直接声明 <code>tom</code> 为 <code>Cat</code> 类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> animal<span class="token operator">:</span> Animal <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'tom'</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> tom<span class="token operator">:</span> Cat <span class="token operator">=</span> animal

<span class="token comment">// Property 'run' is missing in type 'Animal' but required in type 'Cat'.ts(2741)</span>
<span class="token comment">// demo.ts(7, 3): 'run' is declared here.</span>
</code></pre></div><p>则会报错，不允许将 <code>animal</code> 赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p> <p>简单理解，<code>animal</code> 可以看做是 <code>Cat</code> 的父类，当然不能将父类的实例，赋值给，类型为子类的变量。</p> <p>深入理解，它们的核心区别在于：</p> <ul><li><code>animal</code> 断言为 <code>Cat</code>， 只需要满足 <code>Animal</code> 兼容 <code>Cat</code>，或者 <code>Cat</code> 兼容 <code>Animal</code>即可</li> <li><code>animal</code> 赋值给 <code>tom</code>，需要满足 <code>Cat</code> 兼容 <code>Animal</code> 才行，但这里的例子中，<code>Cat</code> 并不兼容 <code>Animal</code></li></ul> <p>知道了它们的核心区别，就知道了类型声明比类型断言更严格。</p> <p>所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 <code>as</code> 语法更加的优雅。</p> <h2 id="类型断言-vs-泛型"><a href="#类型断言-vs-泛型" class="header-anchor">#</a> 类型断言 VS 泛型</h2> <p>还是这个例子</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tom <span class="token operator">=</span> <span class="token function">getCacheData</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> Cat

tom<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>我们还有第三种，可以解决这个问题，那就是泛型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> getCacheData<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>window <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tom <span class="token operator">=</span> getCacheData<span class="token operator">&lt;</span>Cat<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">'tom'</span><span class="token punctuation">)</span>

tom<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中 <code>any</code>，是最优的一个解决方案。</p> <h2 id="问答"><a href="#问答" class="header-anchor">#</a> 问答</h2> <ul><li>类型声明和类型断言哪个更严格，为什么？</li></ul> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li><a href="https://ts.xcatliu.com/basics/type-assertion" target="_blank" rel="noopener noreferrer">TypeScript 入门教程 - 任意值<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/15/2020, 11:12:49 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ts/type-of-function.html" class="prev">
        函数类型
      </a></span> <span class="next"><a href="/ts/declaration-files.html">
        声明文件
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ac774736.js" defer></script><script src="/assets/js/2.ecc89b73.js" defer></script><script src="/assets/js/28.e277d069.js" defer></script>
  </body>
</html>
